import{_ as e,o as a,c as r,Q as i}from"./chunks/framework.fd95ed2e.js";const t="/images/满二叉树.png",l="/images/完全二叉树.png",o="/images/平衡二叉树.png",n="/images/Trie.png",c="/images/patriciaTree.png",s="/images/btree.png",d="/images/b+tree1.png",k=JSON.parse('{"title":"树","description":"","frontmatter":{},"headers":[],"relativePath":"Leetcode/树/树结构.md","filePath":"Leetcode/树/树结构.md"}'),h={name:"Leetcode/树/树结构.md"},p=i('<h1 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h1><p>树是一种特殊的图：唯一起始顶点，其余顶点仅有一个前驱节点；</p><ul><li>二叉树：每个节点有两个子树；</li><li>多叉树：每个节点可能存在多个子树；</li></ul><h2 id="树的数据结构" tabindex="-1">树的数据结构 <a class="header-anchor" href="#树的数据结构" aria-label="Permalink to &quot;树的数据结构&quot;">​</a></h2><h3 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h3><p>按照对二叉树的要求，从严格到宽松，可以对二叉树进行分类，拥有不同的特性；</p><h3 id="满二叉树" tabindex="-1">满二叉树 <a class="header-anchor" href="#满二叉树" aria-label="Permalink to &quot;满二叉树&quot;">​</a></h3><div align="center"><img src="'+t+'" alt="concurrency" align="middle" style="zoom:80%;"></div><h4 id="完全二叉树-heap" tabindex="-1">完全二叉树(Heap) <a class="header-anchor" href="#完全二叉树-heap" aria-label="Permalink to &quot;完全二叉树(Heap)&quot;">​</a></h4><p>1、左右子树最大高度差为1，即：除去最后一层节点为一棵满二叉树； 2、最后一层节点需从左到右分布；</p><p>堆：增加排序的完全二叉树，极值节点永远在根节点；</p><ul><li>MaxHeap：每个节点的值大于子节点；</li><li>MinHeap：每个节点值小于子节点；</li></ul><div align="center"><img src="'+l+'" alt="concurrency" align="middle" style="zoom:80%;"></div><h4 id="平衡二叉树" tabindex="-1">平衡二叉树 <a class="header-anchor" href="#平衡二叉树" aria-label="Permalink to &quot;平衡二叉树&quot;">​</a></h4><p>要求：左右子树最大高度差为1，即：除去最后一层节点为一棵满二叉树； 不要求节点分布顺序；</p><p>AVL树(自平衡二叉树)：当插入节点导致不平衡，通过左旋/右旋来保持平衡的二叉树；使得查询操作的复杂度稳定；</p><ul><li>红黑树就是一棵AVL树；</li></ul><div align="center"><img src="'+o+'" alt="concurrency" align="middle" style="zoom:60%;"></div><h3 id="多叉树" tabindex="-1">多叉树 <a class="header-anchor" href="#多叉树" aria-label="Permalink to &quot;多叉树&quot;">​</a></h3><h4 id="trie-patricia-tree" tabindex="-1">Trie/Patricia Tree <a class="header-anchor" href="#trie-patricia-tree" aria-label="Permalink to &quot;Trie/Patricia Tree&quot;">​</a></h4><p><code>Trie树</code>：按照字典顺序，特化的多叉树；</p><ul><li>将单词结尾标记为根节点(图中红色节点)</li><li>单纯的Trie每个节点保存一个字符，空间浪费，查找效率较低；</li></ul><div align="center"><img src="'+n+'" alt="concurrency" align="middle" style="zoom:70%;"></div><p><code>Patricia Tree</code>：对Trie进行路径压缩后的字典树；</p><ul><li>当出现某路径只有叶子节点，则进行合并；根节点单独一个字符；</li><li>节省空间，降低节点数量；</li><li>增加了插入的复杂度，插入时需要判断是否能够压缩；</li><li>当数据比较==稀疏==，数据之间重复占比很少，适合构建Patricia Tree； <ul><li>分叉的地方比较少，就比较稀疏，适合压缩成一个节点；</li><li>每个字母都出现分叉，就不适合进行路径压缩；</li></ul></li></ul><div align="center"><img src="'+c+'" alt="concurrency" align="middle" style="zoom:90%;"></div><h4 id="b-tree" tabindex="-1">B-Tree <a class="header-anchor" href="#b-tree" aria-label="Permalink to &quot;B-Tree&quot;">​</a></h4><p><img src="'+s+'" alt="BTree"></p><p>B-Tree可以有更低的树高，查找效率更高； 但B-Tree有个很问题，<strong>叶子节点不包含所有值</strong>； 1、范围查找需要回溯； 2、同一个范围，可能涉及多个节点，这意味着可能会执行更多的IO；</p><h4 id="b-tree-1" tabindex="-1">B+Tree <a class="header-anchor" href="#b-tree-1" aria-label="Permalink to &quot;B+Tree&quot;">​</a></h4><p><img src="'+d+'" alt="B+Tree"></p><p>了解到前两个结构的痛点，再看B+Tree的特点： 1、<strong>B+树的叶子节点包含全量索引</strong>；意味着范围查询不需要回溯 2、B+树的叶子节点间是顺序关联的； 3、<strong>顺序增加数据，是最高效的</strong>；</p><h4 id="哈希树-merkle-tree" tabindex="-1">哈希树(Merkle Tree) <a class="header-anchor" href="#哈希树-merkle-tree" aria-label="Permalink to &quot;哈希树(Merkle Tree)&quot;">​</a></h4>',33),m=[p];function u(_,g,b,T,q,f){return a(),r("div",null,m)}const x=e(h,[["render",u]]);export{k as __pageData,x as default};
