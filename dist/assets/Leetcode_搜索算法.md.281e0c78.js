import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.fd95ed2e.js";const F=JSON.parse('{"title":"搜索算法：DFS/BFS","description":"","frontmatter":{},"headers":[],"relativePath":"Leetcode/搜索算法.md","filePath":"Leetcode/搜索算法.md"}'),p={name:"Leetcode/搜索算法.md"},o=l(`<h1 id="搜索算法-dfs-bfs" tabindex="-1">搜索算法：DFS/BFS <a class="header-anchor" href="#搜索算法-dfs-bfs" aria-label="Permalink to &quot;搜索算法：DFS/BFS&quot;">​</a></h1><h2 id="dfs" tabindex="-1">DFS <a class="header-anchor" href="#dfs" aria-label="Permalink to &quot;DFS&quot;">​</a></h2><p>适用问题：</p><ul><li>求解所有路径</li><li>找到一条路径</li><li>某两个顶点是否连通</li></ul><h2 id="bfs" tabindex="-1">BFS <a class="header-anchor" href="#bfs" aria-label="Permalink to &quot;BFS&quot;">​</a></h2><p>适用问题：</p><ul><li>求解所有路径、找到一条路径(某两个顶点是否连通)；</li><li>最短路径问题； <ul><li>如果无权图，则可以找到第一个路径就停止；</li><li>如果有权图，则需要==优先队列==，队列内保持权重排序，每次优先寻找最小权重节点；但是仍然需要遍历能够到达终点的所有可能情况，选择最短的路径；</li></ul></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BFSWithQueue</span><span style="color:#E1E4E8;">(TreeNode root) { </span></span>
<span class="line"><span style="color:#E1E4E8;">	Deque&lt;</span><span style="color:#F97583;">TreeNode</span><span style="color:#E1E4E8;">&gt; queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayDeque&lt;&gt;(); </span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">		queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root); </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">queue.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		TreeNode treeNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">//在这里处理遍历到的TreeNode节点 </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (treeNode.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">			queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(treeNode.left); </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (treeNode.right </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">			queue.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(treeNode.right); </span></span>
<span class="line"><span style="color:#E1E4E8;">	} </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BFSWithQueue</span><span style="color:#24292E;">(TreeNode root) { </span></span>
<span class="line"><span style="color:#24292E;">	Deque&lt;</span><span style="color:#D73A49;">TreeNode</span><span style="color:#24292E;">&gt; queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayDeque&lt;&gt;(); </span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">		queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root); </span></span>
<span class="line"><span style="color:#24292E;">		</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">queue.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">		TreeNode treeNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">		</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">//在这里处理遍历到的TreeNode节点 </span></span>
<span class="line"><span style="color:#24292E;">		</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (treeNode.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">			queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(treeNode.left); </span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (treeNode.right </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">			queue.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(treeNode.right); </span></span>
<span class="line"><span style="color:#24292E;">	} </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,8),e=[o];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const h=s(p,[["render",t]]);export{F as __pageData,h as default};
