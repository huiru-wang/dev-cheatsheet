import{_ as e,o as t,c as o,Q as i}from"./chunks/framework.fd95ed2e.js";const u=JSON.parse('{"title":"回退相关命令","description":"","frontmatter":{},"headers":[],"relativePath":"Git/回退相关命令.md","filePath":"Git/回退相关命令.md"}'),c={name:"Git/回退相关命令.md"},a=i('<h1 id="回退相关命令" tabindex="-1">回退相关命令 <a class="header-anchor" href="#回退相关命令" aria-label="Permalink to &quot;回退相关命令&quot;">​</a></h1><h2 id="回退提交" tabindex="-1">回退提交 <a class="header-anchor" href="#回退提交" aria-label="Permalink to &quot;回退提交&quot;">​</a></h2><h3 id="git-revert" tabindex="-1"><code>git revert</code> <a class="header-anchor" href="#git-revert" aria-label="Permalink to &quot;`git revert`&quot;">​</a></h3><p><code>A --&gt; B</code> <code>git revert</code> <code>A --&gt; B --&gt;C</code></p><p>新增一个commit C，回退掉上次的commit B</p><p>相当于仅提交了 <code>A</code>，但是B的commit记录仍在</p><ul><li>本地工作区commit B 的代码全部回退；</li><li>但是commit B的代码仍存在暂存区；可以恢复；代码仍存在于提交记录中；</li><li>对于主仓分支，一般只能用revert新增来回退，不可用reset强制修改分支；</li></ul><h3 id="git-reset" tabindex="-1"><code>git reset</code> <a class="header-anchor" href="#git-reset" aria-label="Permalink to &quot;`git reset`&quot;">​</a></h3><p>Reset current HEAD to the specified state</p><p>强制将分支回到某个commit</p><p>语法：<code>git reset [commit id]</code></p><p>分支：<code>A --&gt; B --&gt;C</code> git reset --hard [commit B] <code>A --&gt; B</code></p><p>三种模式solf、mixed、hard：</p><p>决定被丢弃的commit，是否从本地删除</p><p>1、<code>--hard</code>：完全丢弃此commit id之后的commit，也就是C完全删除</p><p>2、<code>--soft</code>：重置的commit id 之后的commit，仍存于工作区，即C仍在本地；</p><p>3、<code>--mixed(默认)</code>：保留工作目录，并清空暂存区</p><p>场景：</p><p>1、单纯回退到某个commit</p><p>2、对 commit --amend 同样适用</p><p><code>A --&gt; B(amend) --&gt; C(amend)</code> git reset B <code>A --&gt; B(amend)</code></p><p>3、针对git revert后的情况，revert是通过新增commit来撤销上次commit，可以通过reset恢复，撤销revert；</p><p>4、主仓不可用reset，尽量使用revert；</p><h2 id="回退文件" tabindex="-1">回退文件 <a class="header-anchor" href="#回退文件" aria-label="Permalink to &quot;回退文件&quot;">​</a></h2><h3 id="工作区未stage" tabindex="-1">工作区未stage <a class="header-anchor" href="#工作区未stage" aria-label="Permalink to &quot;工作区未stage&quot;">​</a></h3><p>文件存在于工作区，还未stage，撤销修改，即<code>rollback</code>（返回最新的commit的文件状态）</p><ul><li><code>git restore [filen]</code>✔️推荐</li><li><code>git checkout HEAD -- [file]</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28755652/1671864522905-27060f0a-1e2c-4034-bb37-9593448f031a.png" alt=""></p><h3 id="暂存区未commit" tabindex="-1">暂存区未commit <a class="header-anchor" href="#暂存区未commit" aria-label="Permalink to &quot;暂存区未commit&quot;">​</a></h3><p>文件已经<code>add</code>到暂存区，还未<code>commit</code>，需要撤销<code>stage</code>，并保留修改</p><p>即回到<code>not staged</code>状态：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/28755652/1671864801586-3dfdde18-776d-4031-b64c-de0c6277720f.png" alt=""></p><ul><li><code>git restore --staged [file]</code>✔️推荐</li><li><code>git reset HEAD [file]</code></li></ul><h3 id="已commit未push" tabindex="-1">已commit未push <a class="header-anchor" href="#已commit未push" aria-label="Permalink to &quot;已commit未push&quot;">​</a></h3><p>如果是新文件，不想提交了，希望从commit中删除文件，而不从本地删除：</p><ul><li><code>git rm --cached [file]</code>：文件从git中移除，本地仍在</li><li><code>git commit --amend --allow-empty</code>：删除后，再次提交</li></ul><p>如果是旧文件，不想修改了，希望从commit中取消提交：</p><p>如果还需要此文件的修改，先暂存</p><p>然后，将文件回退到某个commit，然后再add，amend提交：</p><ul><li><code>git checkout [commit_id] -- [file]</code>：将文件回退到指定commit</li><li><code>git add [file] &amp;&amp; git commit --amend</code></li></ul>',40),d=[a];function r(m,l,p,s,n,h){return t(),o("div",null,d)}const _=e(c,[["render",r]]);export{u as __pageData,_ as default};
