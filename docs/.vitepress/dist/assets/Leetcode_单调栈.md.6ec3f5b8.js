import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.fd95ed2e.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Leetcode/单调栈.md","filePath":"Leetcode/单调栈.md"}'),p={name:"Leetcode/单调栈.md"},e=l(`<h2 id="单调栈" tabindex="-1">单调栈 <a class="header-anchor" href="#单调栈" aria-label="Permalink to &quot;单调栈&quot;">​</a></h2><p><strong>单调栈</strong>：以一种策略入栈出栈，保持栈内元素单调;</p><h2 id="解决的问题" tabindex="-1">解决的问题 <a class="header-anchor" href="#解决的问题" aria-label="Permalink to &quot;解决的问题&quot;">​</a></h2><p>1、通常用于解决满足某个条件的下一个元素问题(Next Greater Element问题);</p><p>2、题目数据有单调趋势，并且在不满足单调后，触发一次结算，以此类推，直到找到最优解或最终解；</p><p>如：</p><blockquote><p>一个数组，找到每个元素的后续最近的更大元素；</p><p>保持栈单调递增，即每次元素入栈，栈顶元素都是比当前元素要大，也就是栈顶元素就是当前元素的下一个更大元素；</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">nextGreaterElement</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    Stack&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; stack </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nextGreaterArray </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[nums.length];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 比较栈顶，如不满足单调，则pop出栈</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">stack.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> nums[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            stack.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 处理当前元素,这里是记录当前元素的next greater</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextGreater </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        nextGreaterArray[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextGreater;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 当前元素入栈</span></span>
<span class="line"><span style="color:#E1E4E8;">        stack.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(nums[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">nextGreaterElement</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    Stack&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; stack </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nextGreaterArray </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[nums.length];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 比较栈顶，如不满足单调，则pop出栈</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">stack.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> nums[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> stack.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            stack.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 处理当前元素,这里是记录当前元素的next greater</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextGreater </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stack.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> stack.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        nextGreaterArray[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextGreater;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 当前元素入栈</span></span>
<span class="line"><span style="color:#24292E;">        stack.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(nums[i]);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>针对不同问题场景，以不同的方式处理next element，如：哈希表、记录数值、记录索引等；</p><h2 id="热题" tabindex="-1">热题 <a class="header-anchor" href="#热题" aria-label="Permalink to &quot;热题&quot;">​</a></h2><ul><li><a href="https://leetcode.cn/problems/next-greater-element-i/description/" target="_blank" rel="noreferrer">496. Next Greater Element I</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank" rel="noreferrer">503. Next Greater Element II</a></li><li><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noreferrer">739. Daily Temperatures</a></li><li><a href="https://leetcode.cn/problems/number-of-days-in-a-month/" target="_blank" rel="noreferrer">1118. Number of Days in a Month</a></li><li><a href="https://leetcode.cn/problems/trapping-rain-water/description/" target="_blank" rel="noreferrer">42. Trapping Rain Water</a></li></ul>`,11),o=[e];function t(r,c,E,y,i,m){return n(),a("div",null,o)}const F=s(p,[["render",t]]);export{d as __pageData,F as default};
